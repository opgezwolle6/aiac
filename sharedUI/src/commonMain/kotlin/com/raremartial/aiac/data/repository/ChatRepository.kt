package com.raremartial.aiac.data.repository

import co.touchlab.kermit.Logger
import com.raremartial.aiac.data.mapper.ChatMessageMapper
import com.raremartial.aiac.data.model.ChatMessage
import com.raremartial.aiac.data.model.ComparisonAnalysis
import com.raremartial.aiac.data.model.MessageRole
import com.raremartial.aiac.data.model.SolutionMethod
import com.raremartial.aiac.data.model.SolutionResult
import com.raremartial.aiac.data.model.StructuredResponse
import com.raremartial.aiac.data.model.Temperature
import com.raremartial.aiac.network.YandexGPTApi
import com.raremartial.aiac.network.models.CompletionOptions
import com.raremartial.aiac.network.models.Message
import com.raremartial.aiac.network.models.YandexGPTRequest
import com.raremartial.aiac.util.currentTime
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.jsonPrimitive
import kotlin.time.ExperimentalTime

interface ChatRepository {
    val messages: Flow<List<ChatMessage>>

    suspend fun sendMessage(
        text: String,
        methods: Set<SolutionMethod> = setOf(SolutionMethod.DIRECT),
        temperature: Temperature = Temperature.MEDIUM
    ): Result<ChatMessage>

    suspend fun clearHistory()
}

@OptIn(ExperimentalTime::class)
class ChatRepositoryImpl(
    private val api: YandexGPTApi,
    private val folderId: String
) : ChatRepository {

    private val logger = Logger.withTag("ChatRepository")
    private val json = Json {
        ignoreUnknownKeys = true
        isLenient = true
        prettyPrint = true
    }

    private val _messages = MutableStateFlow<List<ChatMessage>>(emptyList())
    override val messages: Flow<List<ChatMessage>> = _messages.asStateFlow()

    companion object {
        /**
         * Минимальный JSON формат - используется когда выбрана температура
         * Содержит только формат ответа без дополнительных инструкций
         */
        private const val MINIMAL_JSON_FORMAT =
         """Ты — универсальный AI-ассистент. Ответь на запрос пользователя ясно и полно, в свободной форме, без ограничения стиля.
              Используй свои собственные ассоциации, знания и стиль изложения. Дай естественный, цельный ответ на вопрос.
             Твой ответ должен быть валидным JSON объектом в следующем формате:
            {
                "title": "краткий заголовок",
                "answer": "ответ на вопрос",
                "uncertainty_value": 1.0,
                "questions": []
            }
            
            Возвращай только JSON, без markdown разметки и дополнительного текста."""

        private const val BASE_JSON_FORMAT =
            """Твой ответ должен быть ТОЛЬКО валидным JSON объектом без дополнительного текста, без markdown разметки, без обёрток ```json``` или ```.

            СТРОГИЙ ФОРМАТ ОТВЕТА (всегда используй этот формат):
            {
                "title": "краткий заголовок вопроса",
                "answer": "полный развернутый ответ на вопрос",
                "uncertainty_value": 0.0,
                "questions": []
            }
            
            ОПИСАНИЕ ПОЛЕЙ:
            
            1. title (обязательное, строка):
               - Краткий заголовок, отражающий суть вопроса пользователя
               - Длина: 5-15 слов
            
            2. answer (обязательное, строка):
               - Дай полный и точный ответ на основе имеющейся информации
               - Всегда давай финальный ответ, не задавай уточняющих вопросов
            
            3. uncertainty_value (обязательное, число):
               - Всегда устанавливай значение 0.0
               - Это поле обязательно, но не используется для логики неопределенности
            
            4. questions (обязательное, массив строк):
               - Всегда возвращай пустой массив []
               - Не задавай уточняющих вопросов
            
            ВАЖНО: Всегда возвращай валидный JSON. Никаких комментариев, никакой markdown разметки."""

        /**
         * Возвращает системный промпт в зависимости от метода решения и температуры
         * Когда используется температура, возвращается минимальный JSON формат без ограничений
         * Это позволяет YandexGPT быть более свободным в ответах, контролируя только формат вывода
         */
        private fun getSystemPrompt(method: SolutionMethod, temperature: Temperature): String {
            // Всегда используем минимальный формат, когда выбрана температура
            // Это позволяет YandexGPT быть более свободным в ответах
            return MINIMAL_JSON_FORMAT
            
            /* ЗАКОММЕНТИРОВАНО - детальные промпты для методов решения временно не используются
            return when (method) {
                SolutionMethod.DIRECT -> {
                    """⚠️ ВАЖНО: Ты используешь способ "ПРЯМОЙ ОТВЕТ" - это САМЫЙ ПРОСТОЙ способ, но ответ должен быть ТОЧНЫМ и ПРАВИЛЬНЫМ.

Ты - помощник, который дает КРАТКИЕ и ПРЯМЫЕ ответы. Твоя задача - ответить на вопрос максимально лаконично, без лишних слов, но с ГАРАНТИЕЙ ПРАВИЛЬНОСТИ. $BASE_JSON_FORMAT

СТРОГИЕ ПРАВИЛА ДЛЯ СПОСОБА "ПРЯМОЙ ОТВЕТ":

1. ПРОСТОТА И ТОЧНОСТЬ:
   - Это САМЫЙ ПРОСТОЙ способ ответа - без сложных объяснений
   - Но ответ ДОЛЖЕН быть ТОЧНЫМ и ПРАВИЛЬНЫМ
   - Не усложняй, но и не упрощай до потери точности
   - Баланс между простотой и правильностью

2. ГЛУБОКИЙ АНАЛИЗ ПЕРЕД ОТВЕТОМ (но не показывай его в ответе):
   - Внимательно прочитай ВСЕ условия задачи
   - Выяви все ограничения и требования
   - Подумай о логических связях между условиями
   - Убедись, что понимаешь задачу полностью
   - ПРОВЕРЬ правильность решения перед ответом
   - Анализ делай в уме, в ответе - только решение

3. ФОРМАТ ОТВЕТА:
   - ОДИН сплошной абзац текста
   - БЕЗ разбиения на шаги
   - БЕЗ нумерации (1, 2, 3 или Шаг 1, Шаг 2)
   - БЕЗ заголовков или разделов
   - БЕЗ списков с маркерами или дефисами
   - Просто связный текст, который сразу дает решение

4. СТИЛЬ:
   - Кратко и по делу
   - Начинай сразу с решения, без вводных слов
   - Используй простые предложения
   - Избегай фраз типа "Сначала нужно...", "Затем следует...", "В заключение..."
   - Говори просто, но точно

5. КРИТИЧЕСКИ ВАЖНО - ПОЛНОТА И ПРАВИЛЬНОСТЬ:
   - Задача ДОЛЖНА быть решена ПОЛНОСТЬЮ и ПРАВИЛЬНО
   - Если нужно объяснить оба варианта (если вынул чёрный / если вынул белый) - объясни ОБА
   - Если нужно дать финальный ответ - дай его
   - Не останавливайся на полпути, доведи решение до конца
   - ПРОВЕРЬ логику решения перед ответом - ошибки недопустимы
   - Даже если для этого нужно добавить 2-3 дополнительных предложения - добавь их

6. ПРИМЕР ПРАВИЛЬНОГО ОТВЕТА (простой, но полный и правильный):
   "Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — значит в этом ящике два чёрных (надпись ложная). Тогда ящик с надписью «Два чёрных» содержит два белых, а ящик с надписью «Два белых» содержит чёрный и белый. Если вынул белый — значит в этом ящике два белых, тогда ящик с надписью «Два белых» содержит два чёрных, а ящик с надписью «Два чёрных» содержит чёрный и белый."

7. ЧТО НЕПРАВИЛЬНО (НЕ ДЕЛАЙ ТАК):
   ❌ "Шаг 1: Вынь шарик..."
   ❌ "1. Вынь шарик..."
   ❌ "Сначала вынь шарик..."
   ❌ "Решение состоит из следующих этапов:..."
   ❌ "Математик Елена предлагает..."
   ❌ Неполное решение (остановился на полпути)
   ❌ Ошибки в логике решения
   ✅ "Вынь шарик..." (правильно - просто, но полное и правильное решение)

ЗАПОМНИ: Простота - это твоя сила, но точность - это твоя обязанность. Ответ должен быть ПРОСТЫМ, но ПОЛНЫМ и ПРАВИЛЬНЫМ."""
                }

                SolutionMethod.STEP_BY_STEP -> {
                    """⚠️ ВАЖНО: Ты используешь способ "ПОШАГОВОЕ РЕШЕНИЕ" - это БОЛЕЕ ТОЧНЫЙ способ, чем простой ответ. Твой ответ ОБЯЗАТЕЛЬНО должен начинаться с "Шаг 1:" и содержать пронумерованные шаги.

Ты - методичный аналитик, который ОБЯЗАТЕЛЬНО разбивает решение на пронумерованные шаги. Твоя задача - дать ТОЧНЫЙ ответ через пошаговое объяснение. $BASE_JSON_FORMAT

СТРОГИЕ ПРАВИЛА ДЛЯ СПОСОБА "ПОШАГОВОЕ РЕШЕНИЕ":

1. ТОЧНОСТЬ ВЫШЕ ПРОСТОГО ОТВЕТА:
   - Этот способ ДОЛЖЕН быть ТОЧНЕЕ простого ответа
   - Каждый шаг должен быть логически обоснован и проверен
   - Пошаговое объяснение помогает избежать ошибок
   - Точность достигается через детальный анализ на каждом шаге

2. ГЛУБОКИЙ АНАЛИЗ ПЕРЕД РАЗБИЕНИЕМ НА ШАГИ:
   - Внимательно прочитай ВСЕ условия задачи
   - Выяви все ограничения, требования и логические связи
   - Подумай о последовательности действий, необходимых для решения
   - Убедись, что понимаешь задачу полностью
   - Планируй шаги так, чтобы каждый шаг логически вытекал из предыдущего
   - ПРОВЕРЬ правильность каждого шага

3. ОБЯЗАТЕЛЬНЫЙ ФОРМАТ:
   Твой ответ ДОЛЖЕН начинаться со слов "Шаг 1:" и содержать минимум 3-4 шага.
   Каждый шаг ДОЛЖЕН быть пронумерован: "Шаг 1:", "Шаг 2:", "Шаг 3:", и т.д.

4. СТРУКТУРА КАЖДОГО ШАГА:
   Шаг N: [Название шага]
   [Подробное описание того, что делается на этом шаге, почему это необходимо, и как это связано с предыдущими шагами. Объясни логику шага и обоснуй его правильность.]

5. ПРИМЕР ПРАВИЛЬНОГО ОТВЕТА (ОБЯЗАТЕЛЬНО ИСПОЛЬЗУЙ ЭТОТ ФОРМАТ):
   Шаг 1: Анализ условий задачи
   Определяем ключевые факты: у нас три ящика с комбинациями шариков (ЧЧ, ЧБ, ББ), все надписи на крышках ложные, нужно определить содержимое, вынув только один шарик. Этот шаг необходим для понимания ограничений задачи и выявления ключевых условий. Проверка: все условия учтены.

   Шаг 2: Выбор оптимальной стратегии
   Анализируем, из какого ящика вынуть шарик. Ящик с надписью "Чёрный и белый" - единственный, где надпись может быть ложной в обе стороны (может содержать либо ЧЧ, либо ББ). Это делает его идеальной точкой входа, так как результат даст однозначную информацию о содержимом этого ящика, что критично для дальнейших выводов. Проверка: логика выбора обоснована.

   Шаг 3: Выполнение действия и анализ результата
   Вынимаем шарик из ящика с надписью "Чёрный и белый". Если вынули чёрный - значит в этом ящике два чёрных (надпись ложная). Если вынули белый - значит в этом ящике два белых. Этот шаг дает нам конкретную информацию о содержимом одного из ящиков. Проверка: выводы логически верны.

   Шаг 4: Логический вывод для остальных ящиков
   Используя условие, что все надписи ложные, определяем содержимое остальных ящиков. Если в первом ящике ЧЧ, то ящик "Два чёрных" содержит ББ (иначе надпись была бы верной), а ящик "Два белых" содержит ЧБ. Аналогично для случая, если в первом ящике ББ. Проверка: все варианты рассмотрены, логика верна.

   Итог: Один шарик из правильно выбранного ящика дает полную информацию для решения всей задачи благодаря логическим связям между условиями. Решение полное, правильное и проверенное на каждом шаге.

6. ЧТО НЕПРАВИЛЬНО (НЕ ДЕЛАЙ ТАК):
   ❌ "Вынь шарик из ящика..." (без нумерации)
   ❌ "Сначала вынь шарик..." (без "Шаг 1:")
   ❌ Обычный текст без разбиения на шаги
   ❌ Шаги без объяснения логики и связи между ними
   ❌ Неполное решение (не все шаги описаны)
   ❌ Ошибки в логике шагов
   ✅ "Шаг 1: ... Шаг 2: ..." (правильно - с объяснением логики каждого шага и проверкой)

7. КРИТИЧЕСКИ ВАЖНО:
   - Если ты не используешь формат "Шаг 1:", "Шаг 2:" и т.д., твой ответ НЕВЕРЕН
   - Минимум 3 шага, максимум 6-7 шагов
   - Каждый шаг должен быть логически обоснован и ПРОВЕРЕН
   - В конце обязательно добавь "Итог:" с кратким резюме и проверкой правильности решения
   - Точность выше простого ответа - каждый шаг должен быть правильным

ЗАПОМНИ: Твой ответ должен быть ТОЧНЕЕ простого ответа через пошаговое объяснение. Каждый шаг должен быть логически обоснован, проверен и правильным."""
                }

                SolutionMethod.EXPERT_PANEL -> {
                    """⚠️ ВАЖНО: Ты используешь способ "ГРУППА ЭКСПЕРТОВ" - это САМЫЙ ТОЧНЫЙ способ. ОШИБОК БЫТЬ НЕ МОЖЕТ. Твой ответ ОБЯЗАТЕЛЬНО должен содержать решения от 4 разных экспертов с именами и специализациями.

Ты - координатор междисциплинарной группы экспертов. Твоя задача - представить решения от 4 разных экспертов, каждый со своей специализацией. Это САМЫЙ ТОЧНЫЙ способ решения - каждый эксперт должен дать БЕЗОШИБОЧНОЕ решение с использованием методов своей области. ДОПУСКАЕТСЯ использование формул, математических выражений, расчетов. $BASE_JSON_FORMAT
            
            СТРОГИЕ ПРАВИЛА ДЛЯ СПОСОБА "ГРУППА ЭКСПЕРТОВ":
            
            1. САМАЯ ВЫСОКАЯ ТОЧНОСТЬ - БЕЗ ОШИБОК:
               - Это САМЫЙ ТОЧНЫЙ способ решения задачи
               - ОШИБОК БЫТЬ НЕ МОЖЕТ - каждый эксперт должен дать правильное решение
               - Каждый эксперт должен ПРОВЕРИТЬ свое решение перед ответом
               - Точность достигается через применение профессиональных методов каждой области
               - ДОПУСКАЕТСЯ использование формул, математических выражений, расчетов для обоснования

            2. ОБЯЗАТЕЛЬНЫЙ ФОРМАТ ОТВЕТА:
               Твой ответ ДОЛЖЕН содержать решения от 4 экспертов в следующем формате:
               
               [Имя эксперта], [Конкретная специализация]: 
               [Решение с точки зрения этой специализации, используя специфическую терминологию. ОБЯЗАТЕЛЬНО закончи КОНКРЕТНЫМ ОТВЕТОМ на задачу - что именно нужно сделать или какой результат получить.]
               
               [Имя эксперта], [Конкретная специализация]:
               [Решение с точки зрения этой специализации, используя специфическую терминологию. ОБЯЗАТЕЛЬНО закончи КОНКРЕТНЫМ ОТВЕТОМ на задачу.]
               
               [Имя эксперта], [Конкретная специализация]:
               [Решение с точки зрения этой специализации, используя специфическую терминологию. ОБЯЗАТЕЛЬНО закончи КОНКРЕТНЫМ ОТВЕТОМ на задачу.]
               
               КРИТИЧЕСКИ ВАЖНО: 
               - Между ответами разных экспертов ДОЛЖНА быть пустая строка (двойной перенос строки)
               - КАЖДЫЙ эксперт ДОЛЖЕН закончить свой ответ КОНКРЕТНЫМ РЕШЕНИЕМ задачи, а не просто описанием процесса
               - Недостаточно описать, КАК решить - нужно дать ИТОГОВЫЙ ОТВЕТ на вопрос задачи
            
            3. КРИТИЧЕСКИ ВАЖНО ДЛЯ JSON:
               - Все кавычки внутри текста ответов экспертов ДОЛЖНЫ быть экранированы как \\"
               - Не используй одинарные кавычки ' вместо двойных "
               - Все специальные символы должны быть правильно экранированы
               - JSON должен быть валидным и парситься без ошибок
            
            4. ОБЯЗАТЕЛЬНЫЙ СОСТАВ ГРУППЫ (используй именно этих 4 экспертов):
            
               а) МАТЕМАТИК / ЛОГИК:
                  - Это опытный математик с глубоким пониманием логики, комбинаторики и теории множеств
                  - Должен НЕ ПРОСТО использовать термины, а РЕАЛЬНО применять математические методы
                  - Должен формализовать задачу математически: определить множества, отношения, ограничения
                  - Должен строить математические модели и доказывать оптимальность решения
                  - Должен использовать логические операции: исключение, дедукция, индукция
                  - Должен показать, КАК математические принципы применяются к конкретной задаче
                  - ОБЯЗАТЕЛЬНО должен закончить КОНКРЕТНЫМ ОТВЕТОМ на задачу
                  - Пример правильного подхода: "Формализуем задачу как задачу логического вывода с ограничениями. Определим множества A={ЧЧ}, B={ЧБ}, C={ББ} и предикаты P(x)='надпись на ящике x верна'. Из условия: ∀x ¬P(x). Найдем оптимальное решение через анализ информативности каждого действия... [ИТОГОВЫЙ ОТВЕТ]: Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — в этом ящике два чёрных, ящик «Два чёрных» содержит два белых, ящик «Два белых» содержит чёрный и белый. Если вынул белый — в этом ящике два белых, ящик «Два белых» содержит два чёрных, ящик «Два чёрных» содержит чёрный и белый."

               б) ИНЖЕНЕР (специалист по теории информации):
                  - Это опытный инженер с глубоким пониманием теории информации и энтропии
                  - Должен НЕ ПРОСТО упоминать термины, а РЕАЛЬНО применять принципы теории информации
                  - Должен рассчитать информационную ценность каждого возможного действия
                  - Должен использовать понятия энтропии Шеннона, информационного выигрыша
                  - Должен показать, КАК теория информации помогает выбрать оптимальную стратегию
                  - Должен объяснить, почему одно действие информативнее другого с точки зрения энтропии
                  - ОБЯЗАТЕЛЬНО должен закончить КОНКРЕТНЫМ ОТВЕТОМ на задачу
                  - Пример правильного подхода: "С точки зрения теории информации, задача сводится к минимизации энтропии H(X|Y), где X - неизвестное содержимое ящиков, Y - результат измерения. Рассчитаем информационную ценность каждого возможного действия: вынуть шарик из ящика 'Чёрный и белый' дает максимальный информационный выигрыш I(X;Y), так как... [ИТОГОВЫЙ ОТВЕТ]: Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — в этом ящике два чёрных, ящик «Два чёрных» содержит два белых, ящик «Два белых» содержит чёрный и белый. Если вынул белый — в этом ящике два белых, ящик «Два белых» содержит два чёрных, ящик «Два чёрных» содержит чёрный и белый."

               в) АЛГОРИТМИСТ / ПРОГРАММИСТ:
                  - Это опытный алгоритмист с глубоким пониманием структур данных и алгоритмов
                  - Должен НЕ ПРОСТО упоминать термины, а РЕАЛЬНО проектировать алгоритм решения
                  - Должен определить тип задачи (поиск, оптимизация, логический вывод)
                  - Должен выбрать подходящий алгоритмический подход (жадный, динамическое программирование, дерево решений)
                  - Должен рассчитать сложность алгоритма и обосновать выбор
                  - Должен показать структуру данных и последовательность операций
                  - МОЖЕТ использовать формулы для расчета сложности: O(n), O(log n), O(2^n) и т.д.
                  - ОБЯЗАТЕЛЬНО должен закончить КОНКРЕТНЫМ ОТВЕТОМ на задачу
                  - Пример правильного подхода: "Алгоритмически это задача поиска с ограничениями. Используем жадный алгоритм: на каждом шаге выбираем действие с максимальной информационной отдачей. Структура данных: массив ящиков с метаданными. Временная сложность: O(1) для одного действия, пространственная: O(1) для хранения состояния. Алгоритм: 1) Вычислить информационную ценность каждого возможного действия... [ИТОГОВЫЙ ОТВЕТ]: Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — в этом ящике два чёрных, ящик «Два чёрных» содержит два белых, ящик «Два белых» содержит чёрный и белый. Если вынул белый — в этом ящике два белых, ящик «Два белых» содержит два чёрных, ящик «Два чёрных» содержит чёрный и белый."

               г) СПЕЦИАЛИСТ ПО РЕШЕНИЮ ЛОГИЧЕСКИХ ЗАДАЧ:
                  - Это опытный специалист по решению логических задач и головоломок
                  - Должен применять специальные техники решения логических задач: метод исключения, таблицы истинности, логические выводы
                  - Должен использовать формальную логику: импликация (→), конъюнкция (∧), дизъюнкция (∨), отрицание (¬)
                  - Должен строить логические цепочки и проверять их корректность
                  - Должен применять методы дедукции и индукции для решения
                  - МОЖЕТ использовать логические формулы: (A → B) ∧ (B → C) → (A → C)
                  - Должен показать, КАК логические правила применяются к конкретной задаче
                  - ОБЯЗАТЕЛЬНО должен закончить КОНКРЕТНЫМ ОТВЕТОМ на задачу
                  - Пример правильного подхода: "Применим метод логического вывода. Обозначим: A = 'ящик с надписью Два чёрных содержит ЧЧ', B = 'ящик с надписью Два белых содержит ББ', C = 'ящик с надписью Чёрный и белый содержит ЧБ'. Из условия: все надписи ложны, значит: ¬A, ¬B, ¬C. Применим правило исключения: если вынули шарик из ящика 'Чёрный и белый' и он чёрный, то по логике: (¬C ∧ шарик_чёрный) → содержимое_ЧЧ. Затем используем транзитивность: (содержимое_ЧЧ → надпись_ложна) → (ящик_Два_чёрных ≠ ЧЧ) → (ящик_Два_чёрных = ББ)... [ИТОГОВЫЙ ОТВЕТ]: Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — в этом ящике два чёрных, ящик «Два чёрных» содержит два белых, ящик «Два белых» содержит чёрный и белый. Если вынул белый — в этом ящике два белых, ящик «Два белых» содержит два чёрных, ящик «Два чёрных» содержит чёрный и белый."
            
            5. ЧТО НЕПРАВИЛЬНО (НЕ ДЕЛАЙ ТАК):
               ❌ Один ответ без разбиения на экспертов
               ❌ Ответы экспертов одинаковые или похожие
               ❌ Эксперты не используют специфическую терминологию
               ❌ Формат без имен и специализаций
               ❌ Эксперт описывает процесс, но НЕ дает итогового ответа на задачу
               ❌ Эксперт использует формулы и расчеты, но не говорит, что именно нужно сделать
               ✅ Эксперт описывает процесс И дает конкретный итоговый ответ
               ✅ "Математик Елена, специалист по логике: ... 

            Инженер Дмитрий, специалист по теории информации: ... 

            Алгоритмист Алексей, специалист по логическим алгоритмам: ... 

            Логик Сергей, специалист по решению логических задач: ..." (правильно - 4 эксперта, обрати внимание на пустые строки между экспертами)
            
            ПРИМЕР ДЛЯ ЛОГИЧЕСКОЙ ЗАДАЧИ (обрати внимание на пустые строки между экспертами и ГЛУБОКИЙ анализ):

            Математик Елена, специалист по логике и комбинаторике:
            "Формализуем задачу как задачу логического вывода с ограничениями. Определим множества: A={ящик с ЧЧ}, B={ящик с ЧБ}, C={ящик с ББ}. Предикаты: P1(x)='надпись Два чёрных на ящике x верна', P2(x)='надпись Два белых на ящике x верна', P3(x)='надпись Чёрный и белый на ящике x верна'. Из условия: ∀x (¬P1(x) ∧ ¬P2(x) ∧ ¬P3(x)). Задача: найти функцию f: {A,B,C} → {ЧЧ,ЧБ,ББ} при минимальном количестве измерений. Анализ информативности: измерение из ящика с надписью 'Чёрный и белый' дает максимальную информацию, так как результат однозначно определяет содержимое (если чёрный → содержимое ЧЧ, если белый → содержимое ББ), а затем через логические связи (используя условие ложности всех надписей) однозначно определяет содержимое остальных. Математически это оптимальное решение. ИТОГОВЫЙ ОТВЕТ: Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — значит в этом ящике два чёрных (надпись ложная). Тогда ящик с надписью «Два чёрных» содержит два белых, а ящик с надписью «Два белых» содержит чёрный и белый. Если вынул белый — значит в этом ящике два белых, тогда ящик с надписью «Два белых» содержит два чёрных, а ящик с надписью «Два чёрных» содержит чёрный и белый."

            Инженер Дмитрий, специалист по теории информации:
            "С точки зрения теории информации, задача сводится к минимизации условной энтропии H(X|Y), где X - случайная величина содержимого ящиков, Y - результат измерения. Рассчитаем информационную ценность каждого возможного действия: вынуть шарик из ящика 'Два чёрных' дает H(X|Y=чёрный)=log₂(2)=1 бит (неопределенность между ЧЧ и ЧБ), H(X|Y=белый)=log₂(1)=0 бит (однозначно ББ). Аналогично для 'Два белых'. Для ящика 'Чёрный и белый': H(X|Y=чёрный)=0 бит (однозначно ЧЧ), H(X|Y=белый)=0 бит (однозначно ББ). Информационный выигрыш I(X;Y)=H(X)-H(X|Y) максимален для ящика 'Чёрный и белый', так как в обоих случаях энтропия равна 0. Это принцип максимизации взаимной информации - одно измерение дает полную информацию о системе. ИТОГОВЫЙ ОТВЕТ: Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — значит в этом ящике два чёрных (надпись ложная). Тогда ящик с надписью «Два чёрных» содержит два белых, а ящик с надписью «Два белых» содержит чёрный и белый. Если вынул белый — значит в этом ящике два белых, тогда ящик с надписью «Два белых» содержит два чёрных, а ящик с надписью «Два чёрных» содержит чёрный и белый."

            Алгоритмист Алексей, специалист по логическим алгоритмам:
            "Алгоритмически это задача поиска с ограничениями типа constraint satisfaction problem (CSP). Структура данных: массив ящиков с метаданными [ящик, надпись, содержимое_неизвестно]. Алгоритм: жадный выбор действия с максимальной информационной отдачей. На каждом шаге вычисляем информационную ценность каждого возможного действия через функцию infoGain(action) = H(X) - H(X|action_result). Ящик 'Чёрный и белый' имеет максимальный infoGain, так как результат однозначно определяет содержимое. Затем применяем алгоритм логического вывода: используя условие ложности всех надписей, строим дерево решений через backtracking. Временная сложность: O(1) для одного действия, O(n) для полного решения, где n=3 (количество ящиков). Пространственная сложность: O(1) для хранения состояния. Оптимальность доказана через принцип оптимальности Беллмана. ИТОГОВЫЙ ОТВЕТ: Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — значит в этом ящике два чёрных (надпись ложная). Тогда ящик с надписью «Два чёрных» содержит два белых, а ящик с надписью «Два белых» содержит чёрный и белый. Если вынул белый — значит в этом ящике два белых, тогда ящик с надписью «Два белых» содержит два чёрных, а ящик с надписью «Два чёрных» содержит чёрный и белый."

            Логик Сергей, специалист по решению логических задач:
            "Применим метод формальной логики. Обозначим предикаты: P1 = 'ящик с надписью Два чёрных содержит ЧЧ', P2 = 'ящик с надписью Два белых содержит ББ', P3 = 'ящик с надписью Чёрный и белый содержит ЧБ'. Из условия: все надписи ложны, значит: ¬P1, ¬P2, ¬P3. Применим правило логического вывода: если вынули шарик из ящика 'Чёрный и белый' и он чёрный, то по правилу modus ponens: (¬P3 ∧ шарик_чёрный) → содержимое_ЧЧ. Затем используем транзитивность логических связей: (содержимое_ЧЧ → ¬P1) → (ящик_Два_чёрных ≠ ЧЧ). Применяя закон исключенного третьего и условие ¬P1, получаем: ящик_Два_чёрных = ББ. Аналогично для остальных ящиков. Логическая цепочка: (A → B) ∧ (B → C) → (A → C), где A = результат измерения, B = содержимое первого ящика, C = содержимое остальных ящиков. ИТОГОВЫЙ ОТВЕТ: Вынь шарик из ящика с надписью «Чёрный и белый». Если вынул чёрный — значит в этом ящике два чёрных (надпись ложная). Тогда ящик с надписью «Два чёрных» содержит два белых, а ящик с надписью «Два белых» содержит чёрный и белый. Если вынул белый — значит в этом ящике два белых, тогда ящик с надписью «Два белых» содержит два чёрных, а ящик с надписью «Два чёрных» содержит чёрный и белый."
            
            6. КРИТИЧЕСКИ ВАЖНО ДЛЯ КАЧЕСТВА ОТВЕТОВ (САМАЯ ВЫСОКАЯ ТОЧНОСТЬ):
            - Это САМЫЙ ТОЧНЫЙ способ - ОШИБОК БЫТЬ НЕ МОЖЕТ
            - Каждый эксперт ДОЛЖЕН иметь конкретное имя и специализацию
            - Каждый эксперт ДОЛЖЕН НЕ ПРОСТО использовать термины, а РЕАЛЬНО применять методы своей области
            - Каждый эксперт ДОЛЖЕН показать ГЛУБОКОЕ понимание задачи через призму своей специализации
            - Эксперты должны давать РАЗНЫЕ подходы к решению, но все должны быть ПРАВИЛЬНЫМИ и БЕЗОШИБОЧНЫМИ
            - Эксперты должны показать РАСЧЕТЫ, ФОРМАЛИЗАЦИЮ, ФОРМУЛЫ или ДЕТАЛЬНЫЙ АНАЛИЗ, а не просто упоминать термины
            - ДОПУСКАЕТСЯ использование формул: математических (H(X|Y) = -Σ P(x|y)log₂P(x|y)), логических ((A → B) ∧ (B → C) → (A → C)), алгоритмических (O(n), O(log n))
            - Каждый эксперт ДОЛЖЕН ПРОВЕРИТЬ свое решение перед ответом
            - Решения должны быть полными, правильными и БЕЗОШИБОЧНЫМИ
            - Покажи, как разные области знаний подходят к одной задаче по-разному, но все приходят к ПРАВИЛЬНОМУ решению
            
            7. ОБЯЗАТЕЛЬНО - ИТОГОВЫЙ ОТВЕТ:
            - КАЖДЫЙ эксперт ДОЛЖЕН закончить свой ответ КОНКРЕТНЫМ ИТОГОВЫМ ОТВЕТОМ на задачу
            - Недостаточно описать процесс решения - нужно дать ФИНАЛЬНЫЙ ОТВЕТ
            - Итоговый ответ должен быть конкретным: что именно нужно сделать, какой результат получить
            - Итоговый ответ должен быть полным и решать задачу до конца
            - Можно использовать фразу "ИТОГОВЫЙ ОТВЕТ:" перед финальным решением
            - Пример: после всех расчетов и формул эксперт должен сказать: "ИТОГОВЫЙ ОТВЕТ: [конкретное решение задачи]"
            
            ЗАПОМНИ: Эксперты - это ПРОФЕССИОНАЛЫ ВЫСШЕГО УРОВНЯ, которые РЕАЛЬНО применяют методы своей науки для БЕЗОШИБОЧНОГО решения задачи. Это САМЫЙ ТОЧНЫЙ способ - ошибки недопустимы. Используй формулы, расчеты, формализацию для обоснования правильности решения. НО ГЛАВНОЕ - каждый эксперт ДОЛЖЕН дать КОНКРЕТНЫЙ ИТОГОВЫЙ ОТВЕТ на задачу, а не просто описать процесс."""
                }
            }
            */
        }

        private const val COMPARISON_PROMPT =
        """Ты - аналитик, который сравнивает разные способы решения задачи. Проанализируй предоставленные решения и создай итоговый анализ.
        
        СТРОГИЙ ФОРМАТ ОТВЕТА (всегда используй этот формат):
        {
            "summary": "краткое резюме всех способов решения",
            "prosAndCons": {
                "DIRECT": ["преимущество 1", "преимущество 2"],
                "STEP_BY_STEP": ["преимущество 1", "недостаток 1"],
                "EXPERT_PANEL": ["преимущество 1", "недостаток 1"]
            },
            "recommendation": "рекомендация по выбору лучшего способа",
            "bestMethod": "DIRECT" или "STEP_BY_STEP" или "EXPERT_PANEL"
        }
        
        ВАЖНО: Всегда возвращай валидный JSON. Никаких комментариев, никакой markdown разметки."""

        private const val UNCERTAINTY_THRESHOLD = 0.1
        
        /**
         * Возвращает значение температуры
         * Используются три типа температуры: 0.0, 0.5, 1.0
         */
        private fun getTemperatureValue(temperature: Temperature): Double {
            return when (temperature) {
                Temperature.LOW -> 0.0   // Низкая температура - детерминированные, точные ответы
                Temperature.MEDIUM -> 0.5  // Средняя температура - сбалансированные ответы
                Temperature.HIGH -> 1.0  // Высокая температура - креативные, разнообразные ответы
            }
        }
    }

    override suspend fun sendMessage(
        text: String,
        methods: Set<SolutionMethod>,
        temperature: Temperature
    ): Result<ChatMessage> {
        val userMessage = ChatMessage(
            id = ChatMessageMapper.generateId(),
            content = text,
            role = MessageRole.USER,
            timestamp = currentTime(),
            selectedMethods = methods.toList()
        )

        _messages.value = _messages.value + userMessage

        // Если выбран только один способ, используем старую логику
        if (methods.size == 1) {
            val method = methods.first()
            return sendMessageWithMethod(text, method, userMessage, temperature)
        }

        // Если выбрано несколько способов, отправляем запросы параллельно
        return sendMessageWithMultipleMethods(text, methods, userMessage, temperature)
    }

    /**
     * Отправляет сообщение с одним способом решения
     */
    private suspend fun sendMessageWithMethod(
        text: String,
        method: SolutionMethod,
        userMessage: ChatMessage,
        temperature: Temperature
    ): Result<ChatMessage> {
        val pendingMessage = ChatMessage(
            id = ChatMessageMapper.generateId(),
            content = "",
            role = MessageRole.ASSISTANT,
            timestamp = currentTime(),
            isPending = true
        )
        _messages.value = _messages.value + pendingMessage

        val conversationHistory = _messages.value
            .filter { !it.isPending && it.id != pendingMessage.id }
            .map { ChatMessageMapper.toNetwork(it) }

        val systemPrompt = getSystemPrompt(method, temperature)
        val networkMessages =
            listOf(Message(role = "system", text = systemPrompt)) + conversationHistory

        val temperatureValue = getTemperatureValue(temperature)
        val request = YandexGPTRequest(
            modelUri = "",
            completionOptions = CompletionOptions(temperature = temperatureValue),
            messages = networkMessages
        )

        logger.d { "Sending message with method $method: text=${text.take(50)}..., temperature=$temperatureValue (${temperature.name})" }

        val result = api.sendMessage(request)

        return result.fold(
            onSuccess = { response ->
                val responseMessage = response.result?.alternatives?.firstOrNull()?.message

                if (responseMessage == null) {
                    _messages.value = _messages.value.filter { it.id != pendingMessage.id }
                    return Result.failure(Exception("Empty response from YandexGPT API"))
                }

                logger.d {
                    "Raw JSON response from YandexGPT:\n${
                        formatJsonForLogging(
                            responseMessage.text
                        )
                    }"
                }

                val structuredResponse = parseStructuredResponse(responseMessage.text)

                if (structuredResponse == null) {
                    _messages.value = _messages.value.filter { it.id != pendingMessage.id }
                    return Result.failure(Exception("Failed to parse structured response from YandexGPT"))
                }

                val assistantMessage = ChatMessage(
                    id = pendingMessage.id,
                    content = structuredResponse.answer,
                    role = MessageRole.ASSISTANT,
                    timestamp = currentTime(),
                    isPending = false,
                    structuredData = structuredResponse.copy(solutionMethod = method)
                )

                _messages.value = _messages.value
                    .filter { it.id != pendingMessage.id } + assistantMessage

                Result.success(assistantMessage)
            },
            onFailure = { exception ->
                logger.e(exception) { "Failed to send message: ${exception.message}" }
                _messages.value = _messages.value.filter { it.id != pendingMessage.id }
                Result.failure(exception)
            }
        )
    }

    /**
     * Отправляет сообщение с несколькими способами решения и создает итоговый анализ
     */
    private suspend fun sendMessageWithMultipleMethods(
        text: String,
        methods: Set<SolutionMethod>,
        userMessage: ChatMessage,
        temperature: Temperature
    ): Result<ChatMessage> {
        val pendingMessage = ChatMessage(
            id = ChatMessageMapper.generateId(),
            content = "Обрабатываю запрос несколькими способами...",
            role = MessageRole.ASSISTANT,
            timestamp = currentTime(),
            isPending = true
        )
        _messages.value = _messages.value + pendingMessage

        // Отправляем запросы для каждого способа параллельно
        val conversationHistory = _messages.value
            .filter { !it.isPending && it.id != pendingMessage.id }
            .map { ChatMessageMapper.toNetwork(it) }

        val solutionResults = coroutineScope {
            methods.map { method ->
                async {
                    val systemPrompt = getSystemPrompt(method, temperature)
                    val networkMessages =
                        listOf(Message(role = "system", text = systemPrompt)) + conversationHistory

                    val temperatureValue = getTemperatureValue(temperature)
                    val request = YandexGPTRequest(
                        modelUri = "",
                        completionOptions = CompletionOptions(temperature = temperatureValue),
                        messages = networkMessages
                    )

                    logger.d { "Sending message with method $method: text=${text.take(50)}..., temperature=$temperatureValue (${temperature.name})" }

                    val result = api.sendMessage(request)

                    result.fold(
                        onSuccess = { response ->
                            val responseMessage =
                                response.result?.alternatives?.firstOrNull()?.message

                            if (responseMessage != null) {
                                logger.d {
                                    "Raw JSON response for $method:\n${
                                        formatJsonForLogging(
                                            responseMessage.text
                                        )
                                    }"
                                }

                                val structuredResponse =
                                    parseStructuredResponse(responseMessage.text)

                                if (structuredResponse != null) {
                                    SolutionResult(
                                        method = method,
                                        title = structuredResponse.title,
                                        answer = structuredResponse.answer,
                                        uncertainty_value = structuredResponse.uncertainty_value,
                                        questions = structuredResponse.questions
                                    )
                                } else {
                                    null
                                }
                            } else {
                                null
                            }
                        },
                        onFailure = { exception ->
                            logger.e(exception) { "Failed to send message with method $method: ${exception.message}" }
                            null
                        }
                    )
                }
            }.awaitAll().filterNotNull()
        }

        if (solutionResults.isEmpty()) {
            _messages.value = _messages.value.filter { it.id != pendingMessage.id }
            return Result.failure(Exception("Failed to get responses from any method"))
        }

        // Сортируем результаты по фиксированному порядку: DIRECT, STEP_BY_STEP, EXPERT_PANEL
        val sortedResults = solutionResults.sortedBy { result ->
            when (result.method) {
                SolutionMethod.DIRECT -> 1
                SolutionMethod.STEP_BY_STEP -> 2
                SolutionMethod.EXPERT_PANEL -> 3
            }
        }

        // Создаем итоговый анализ, если есть несколько результатов
        val comparisonAnalysis = if (sortedResults.size > 1) {
            createComparisonAnalysis(text, sortedResults)
        } else {
            null
        }

        // Формируем итоговое сообщение
        val combinedContent = buildString {
            sortedResults.forEachIndexed { index, result ->
                appendLine("**${getMethodName(result.method)}:**")
                appendLine(result.answer)
                // Добавляем пустую строку между способами, кроме последнего
                if (index < sortedResults.size - 1) {
                    appendLine()
                }
            }
            if (comparisonAnalysis != null) {
                appendLine("**Итоговый анализ:**")
                appendLine(comparisonAnalysis.summary)
                appendLine()
                appendLine("**Рекомендация:** ${comparisonAnalysis.recommendation}")
            }
        }

        val assistantMessage = ChatMessage(
            id = pendingMessage.id,
            content = combinedContent.trim(),
            role = MessageRole.ASSISTANT,
            timestamp = currentTime(),
            isPending = false,
            solutionResults = sortedResults,
            comparisonAnalysis = comparisonAnalysis,
            selectedMethods = methods.toList()
        )

        _messages.value = _messages.value
            .filter { it.id != pendingMessage.id } + assistantMessage

        logger.d { "Message with ${sortedResults.size} methods successfully processed" }
        return Result.success(assistantMessage)
    }

    /**
     * Создает итоговый анализ всех способов решения
     */
    private suspend fun createComparisonAnalysis(
        originalQuestion: String,
        results: List<SolutionResult>
    ): ComparisonAnalysis? {
        val comparisonText = buildString {
            appendLine("Вопрос: $originalQuestion")
            appendLine()
            appendLine("Решения:")
            results.forEach { result ->
                appendLine("${getMethodName(result.method)}: ${result.answer}")
            }
        }

        val conversationHistory = _messages.value
            .filter { !it.isPending }
            .map { ChatMessageMapper.toNetwork(it) }

        val networkMessages = listOf(
            Message(role = "system", text = COMPARISON_PROMPT),
            Message(role = "user", text = comparisonText)
        ) + conversationHistory

        // Для анализа используем низкую температуру для точности
        val request = YandexGPTRequest(
            modelUri = "",
            completionOptions = CompletionOptions(temperature = 0.2),
            messages = networkMessages
        )

        logger.d { "Creating comparison analysis for ${results.size} methods" }

        val result = api.sendMessage(request)

        return result.fold(
            onSuccess = { response ->
                val responseMessage = response.result?.alternatives?.firstOrNull()?.message

                if (responseMessage != null) {
                    try {
                        var jsonText = responseMessage.text
                            .trim()
                            .removePrefix("```json")
                            .removePrefix("```")
                            .removeSuffix("```")
                            .trim()

                        if (!jsonText.startsWith("{")) {
                            val jsonStart = jsonText.indexOf("{")
                            val jsonEnd = jsonText.lastIndexOf("}")
                            if (jsonStart >= 0 && jsonEnd > jsonStart) {
                                jsonText = jsonText.substring(jsonStart, jsonEnd + 1)
                            }
                        }

                        // Парсим JSON для сравнения
                        val jsonObject = json.parseToJsonElement(jsonText).jsonObject

                        val summary = jsonObject["summary"]?.jsonPrimitive?.content ?: ""
                        val recommendation =
                            jsonObject["recommendation"]?.jsonPrimitive?.content ?: ""
                        val bestMethodStr = jsonObject["bestMethod"]?.jsonPrimitive?.content ?: ""
                        val bestMethod = try {
                            SolutionMethod.valueOf(bestMethodStr)
                        } catch (e: Exception) {
                            null
                        }

                        val prosAndCons = mutableMapOf<String, List<String>>()
                        jsonObject["prosAndCons"]?.jsonObject?.forEach { (key, value) ->
                            val list = value.jsonArray.map { it.jsonPrimitive.content }
                            prosAndCons[key] = list
                        }

                        ComparisonAnalysis(
                            summary = summary,
                            prosAndCons = prosAndCons,
                            recommendation = recommendation,
                            bestMethod = bestMethod
                        )
                    } catch (e: Exception) {
                        logger.e(e) {
                            "Failed to parse comparison analysis: ${
                                responseMessage.text.take(
                                    200
                                )
                            }"
                        }
                        null
                    }
                } else {
                    null
                }
            },
            onFailure = { exception ->
                logger.e(exception) { "Failed to create comparison analysis: ${exception.message}" }
                null
            }
        )
    }

    private fun getMethodName(method: SolutionMethod): String {
        return when (method) {
            SolutionMethod.DIRECT -> "Способ 1: Прямой ответ"
            SolutionMethod.STEP_BY_STEP -> "Способ 2: Пошаговое решение"
            SolutionMethod.EXPERT_PANEL -> "Способ 3: Группа экспертов"
        }
    }

//    private suspend fun sendMessageWithRetries(
//        originalText: String,
//        userMessage: ChatMessage,
//        retryCount: Int
//    ): Result<ChatMessage> {
//        val pendingMessage = ChatMessage(
//            id = ChatMessageMapper.generateId(),
//            content = "",
//            role = MessageRole.ASSISTANT,
//            timestamp = currentTime(),
//            isPending = true
//        )
//        _messages.value = _messages.value + pendingMessage
//
//        // Получаем историю сообщений без pending сообщений
//        val conversationHistory = _messages.value
//            .filter { !it.isPending && it.id != pendingMessage.id }
//            .map { ChatMessageMapper.toNetwork(it) }
//
//        // Добавляем системный промпт только в первый запрос (retryCount == 0)
//        // YandexGPT сохраняет контекст системного сообщения в разговоре
//        val networkMessages = if (retryCount == 0) {
//            listOf(Message(role = "system", text = SYSTEM_PROMPT)) + conversationHistory
//        } else {
//            // При повторных запросах системный промпт уже был отправлен ранее
//            // и YandexGPT сохраняет его в контексте, поэтому отправляем только историю
//            conversationHistory
//        }
//
//        val request = YandexGPTRequest(
//            modelUri = "",
//            completionOptions = CompletionOptions(),
//            messages = networkMessages
//        )
//
//        logger.d { "Sending message to API: text=${originalText.take(50)}..., messagesCount=${networkMessages.size}, retryCount=$retryCount" }
//
//        val result = api.sendMessage(request)
//
//        return result.fold(
//            onSuccess = { response ->
//                logger.d { "API response received: result=${response.result != null}, alternativesCount=${response.result?.alternatives?.size ?: 0}" }
//
//                val responseMessage = response.result?.alternatives?.firstOrNull()?.message
//
//                if (responseMessage == null) {
//                    logger.e { "Empty response from API: result=${response.result}, alternatives=${response.result?.alternatives}" }
//                    _messages.value = _messages.value.filter { it.id != pendingMessage.id }
//                    return Result.failure(Exception("Empty response from YandexGPT API"))
//                }
//
//                logger.d { "Response message extracted: role=${responseMessage.role}, textLength=${responseMessage.text.length}" }
//
//                // Логируем сырой JSON ответ от YandexGPT
//                logger.d { "Raw JSON response from YandexGPT:\n${formatJsonForLogging(responseMessage.text)}" }
//
//                // Парсим JSON ответ
//                val structuredResponse = parseStructuredResponse(responseMessage.text)
//
//                if (structuredResponse == null) {
//                    logger.e {
//                        "Failed to parse structured response from: ${
//                            responseMessage.text.take(
//                                200
//                            )
//                        }"
//                    }
//                    _messages.value = _messages.value.filter { it.id != pendingMessage.id }
//                    return Result.failure(Exception("Failed to parse structured response from YandexGPT"))
//                }
//
//                logger.d {
//                    "Parsed structured response: title=${structuredResponse.title.take(50)}, " +
//                            "uncertainty=${structuredResponse.uncertainty_value}, " +
//                            "questionsCount=${structuredResponse.questions.size}"
//                }
//
//                // Если неопределенность высокая (> 0.1), YandexGPT должен был задать уточняющие вопросы
//                // Показываем ответ с вопросами и ждем ответа пользователя
//                // Если неопределенность <= 0.1, показываем финальный ответ
//                val assistantMessage = ChatMessage(
//                    id = pendingMessage.id,
//                    content = structuredResponse.answer,
//                    role = MessageRole.ASSISTANT,
//                    timestamp = currentTime(),
//                    isPending = false,
//                    structuredData = structuredResponse
//                )
//
//                _messages.value = _messages.value
//                    .filter { it.id != pendingMessage.id } + assistantMessage
//
//                if (structuredResponse.uncertainty_value > UNCERTAINTY_THRESHOLD) {
//                    logger.d {
//                        "High uncertainty detected (${structuredResponse.uncertainty_value}), " +
//                                "showing response with clarification questions. " +
//                                "Waiting for user's answers to questions: ${structuredResponse.questions}"
//                    }
//                } else {
//                    logger.d { "Uncertainty is acceptable (${structuredResponse.uncertainty_value} <= $UNCERTAINTY_THRESHOLD), showing final answer" }
//                }
//
//                logger.d { "Message successfully processed and added to chat" }
//                Result.success(assistantMessage)
//            },
//            onFailure = { exception ->
//                logger.e(exception) { "Failed to send message: ${exception.message}" }
//                _messages.value = _messages.value.filter { it.id != pendingMessage.id }
//                Result.failure(exception)
//            }
//        )
//    }

    private fun parseStructuredResponse(text: String): StructuredResponse? {
        return try {
            // Пытаемся найти JSON в тексте (может быть обёрнут в markdown)
            var jsonText = text
                .trim()
                .removePrefix("```json")
                .removePrefix("```")
                .removeSuffix("```")
                .trim()

            // Если текст не начинается с "{", пытаемся найти JSON объект в тексте
            if (!jsonText.startsWith("{")) {
                val jsonStart = jsonText.indexOf("{")
                val jsonEnd = jsonText.lastIndexOf("}")
                if (jsonStart >= 0 && jsonEnd > jsonStart) {
                    jsonText = jsonText.substring(jsonStart, jsonEnd + 1)
                }
            }

            // Улучшенная обработка: пытаемся найти и исправить незакрытые строки
            // Если есть незакрытые кавычки, пытаемся их исправить
            jsonText = fixJsonString(jsonText)

            json.decodeFromString<StructuredResponse>(jsonText)
        } catch (e: Exception) {
            logger.e(e) { "Failed to parse structured response: ${text.take(200)}" }
            // Пытаемся более агрессивно извлечь JSON
            try {
                val jsonStart = text.indexOf("{")
                val jsonEnd = text.lastIndexOf("}")
                if (jsonStart >= 0 && jsonEnd > jsonStart) {
                    var extractedJson = text.substring(jsonStart, jsonEnd + 1)
                    extractedJson = fixJsonString(extractedJson)
                    json.decodeFromString<StructuredResponse>(extractedJson)
                } else {
                    null
                }
            } catch (e2: Exception) {
                logger.e(e2) { "Failed to parse even after extraction: ${text.take(200)}" }
                null
            }
        }
    }

    /**
     * Исправляет распространенные проблемы с JSON строками
     * Основная проблема: неэкранированные кавычки внутри строковых значений
     */
    private fun fixJsonString(jsonText: String): String {
        try {
            // Пытаемся найти поле "answer" и исправить кавычки внутри его значения
            // Используем [\s\S] вместо . для совпадения с любым символом, включая перенос строки
            val answerPattern = Regex("""("answer"\s*:\s*")([\s\S]*?)(")""")
            
            return answerPattern.replace(jsonText) { matchResult ->
                val prefix = matchResult.groupValues[1]  // "answer": "
                val content = matchResult.groupValues[2]  // содержимое между кавычками
                val suffix = matchResult.groupValues[3]   // закрывающая кавычка
                
                // Экранируем все неэкранированные кавычки внутри содержимого
                // Но сохраняем уже экранированные кавычки (\")
                val fixedContent = StringBuilder()
                var i = 0
                while (i < content.length) {
                    if (content[i] == '\\' && i + 1 < content.length) {
                        // Уже экранированный символ
                        fixedContent.append(content[i])
                        fixedContent.append(content[i + 1])
                        i += 2
                    } else if (content[i] == '"') {
                        // Неэкранированная кавычка - экранируем её
                        fixedContent.append("\\\"")
                        i++
                    } else {
                        fixedContent.append(content[i])
                        i++
                    }
                }
                
                prefix + fixedContent.toString() + suffix
            }
        } catch (e: Exception) {
            logger.e(e) { "Failed to fix JSON string, returning original" }
            return jsonText
        }
    }

    /**
     * Форматирует JSON текст для красивого вывода в логах
     */
    private fun formatJsonForLogging(jsonText: String): String {
        return try {
            // Пытаемся найти JSON в тексте
            var cleanedText = jsonText
                .trim()
                .removePrefix("```json")
                .removePrefix("```")
                .removeSuffix("```")
                .trim()

            // Если текст не начинается с "{", пытаемся найти JSON объект
            if (!cleanedText.startsWith("{")) {
                val jsonStart = cleanedText.indexOf("{")
                val jsonEnd = cleanedText.lastIndexOf("}")
                if (jsonStart >= 0 && jsonEnd > jsonStart) {
                    cleanedText = cleanedText.substring(jsonStart, jsonEnd + 1)
                }
            }

            // Парсим и форматируем JSON
            val parsed = json.decodeFromString<StructuredResponse>(cleanedText)
            json.encodeToString(StructuredResponse.serializer(), parsed)
        } catch (e: Exception) {
            // Если не удалось распарсить, возвращаем исходный текст
            jsonText
        }
    }

    /**
     * Форматирует структурированный ответ для вывода в логах
     */
    private fun formatStructuredResponse(response: StructuredResponse): String {
        return try {
            json.encodeToString(StructuredResponse.serializer(), response)
        } catch (e: Exception) {
            "Failed to format structured response: ${e.message}"
        }
    }

    override suspend fun clearHistory() {
        _messages.value = emptyList()
    }
}

